


define join_S1 = join(S1, S1)

define join_S1_pointed = pointed.make(@join_S1, join_S1.inl(S1.base))

define join_S1_facek01(i j k: I): join_S1 =
  hfill(join_S1.push(S1.base, S1.base, ~k)
  |~j: l → join_S1.push(S1.base, S1.base, (~l)∧(~k))
  | j: l → join_S1.push(S1.base, S1.base, (~l)∧(~k))
  |~k: l → join_S1.push(S1.loop(j), S1.base, (~l))
  | k: l → join_S1.inl(S1.base)
  )(i)

// TODO support border k or, or expressions in partial elements
define join_S1_border_contraction(i j k m: I): join_S1 =
  hfill(join_S1.push(S1.loop(j), S1.loop(k), i)
  |~i: l → join_S1_facek01(1, j, l)
  | i: l → join_S1.push(S1.base, S1.loop(k), ~l)
  |~j: l → join_S1.push(S1.base, S1.loop(k), (i)∧(~l))
  | j: l → join_S1.push(S1.base, S1.loop(k), (i)∧(~l))
  |~k: l → join_S1_facek01(~i, j, l)
  | k: l → join_S1_facek01(~i, j, l)
  )(m)



define S3_to_join_S1
: S3 ⇒ join_S1 =
┌ base → join_S1.inl(S1.base)
└ surf(j, k, i) → join_S1_border_contraction(i, j, k, 1)

// JUST pasting here for now, delete when it works

define alpha: join_S1 ⇒ S2 =
┌ inl(s) → S2.base
├ inr(s) → S2.base
└ push(x, y, i) → path_compose(S2_merid(y), S2_merid(x))(i)

define test_0_to_2: loop_space_3(S3_pointed).A =
  i → j → k → S3.surf(i, j, k)

define f3: loop_space_3(S3_pointed).A ⇒ loop_space_3(join_S1_pointed).A =
  p → i → j → k → S3_to_join_S1(p(i, j, k))

define test_0_to_3: loop_space_3(join_S1_pointed).A =
  f3(test_0_to_2)

define f4: loop_space_3(join_S1_pointed).A ⇒ loop_space_3(S2_pointed).A =
  p → i → j → k → alpha(p(i, j, k))

define test_0_to_4: loop_space_3(S2_pointed).A =
  f4(test_0_to_3)

define interpath(i j: I): S2_hopf(test_0_to_4(i, j, 1)) =
  transp(k → S2_hopf(test_0_to_4(i, j, k)), 0, S1.base)

define __debug problem: int.pos(zero) ≡ int.pos(zero) =
  i → transp(j → S1_helix(interpath(i ,j)), 0, int.pos(zero))









define inductively post_total_hopf: type = sum {
  case base(: S1)
  case loop(x: S1, i j: I
  |i: base(x)
  |~i: base(x)
  |~j: base(x)
  |j: base(rot_loop(x, ~i))
  )
}
define tee12:
 (x: S2, y: S2_hopf(x)) ⇒ post_total_hopf =
┌ base → y → post_total_hopf.base(y)
└ surf(i, j) → y →
    hcomp(post_total_hopf.loop(unglue(y), i, j)
    |~i: k → post_total_hopf.base(y)
    |i: k → post_total_hopf.base(y)
    |~j: k → post_total_hopf.base(y)
    |j: k → post_total_hopf.base(rot_loop_inv(y, ~i, k))
    )

define tee34: post_total_hopf ⇒ join_S1 =
┌ base(x) → join_S1.inl(x)
└ loop(x, i, j) → hcomp(join_S1.push(x, x, j)
                  |~i: k → join_S1.push(x, x, j∧(~k))
                  |i: k → join_S1.push(x, x, j∧(~k))
                  |~j: k → join_S1.inl(x)
                  |j: k → join_S1.push(rot_loop(x, ~i), x, ~k)
                  )

define tee(x: S2, y: S2_hopf(x)): join_S1 = tee34(tee12(x, y))

/**

**/
