

/*

// TODO implement type annotation (only allowing equality types)
define inductively S1: type = sum {
  case base
  case loop: base ≡ base
}

// TODO implement boundary like redtt
define inductively S2: type = sum {
  case base
  case surf(i j: I | ∂(i, j): base)
}
*/


define inductively S1: type = sum {
  case base
  case loop(i: I | ~i: base | i: base)
}


define S1_moebius
: S1      ⇒ type =
┌ base    → bool
└ loop(i) → bool_path_to_neg_bool(i)


define S1_helix:
S1        ⇒ type =
┌ base    → int
└ loop(i) → int_suc_path(i)


define S1_pointed: pointed = make(S1.base)

