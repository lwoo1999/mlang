

/*

// TODO implement type annotation (only allowing equality types)
define S1: type = sum {
  case base
  case loop: base ≡ base
}

// TODO implement boundary like redtt
define S2: type = sum {
  case base
  case surf(i j: I | ∂(i, j): base)
}
*/


define S1: type = sum {
  case base
  case loop(i: I | ~i: base | i: base)
}


// S1_join_S1 related

define S1_moebius
: S1      ⇒ type =
┌ base    → bool
└ loop(i) → bool_path_to_neg_bool(i)


define S1_helix:
S1        ⇒ type =
┌ base    → int
└ loop(i) → int_suc_path(i)


define S1_pointed: pointed = make(S1.base)


define rot_loop:
 (a: S1) ⇒ a ≡ a =
┌ base    → j → S1.loop(j)
└ loop(i) → j → hcomp(S1.base |~i: k → S1.loop(j∨(~k)) |i: k → S1.loop(j∧k) |~j: k → S1.loop(i∨(~k)) |j: k → S1.loop(i∧k) )

define rot: S1 ⇒ S1 ⇒ S1 =
┌ base → x → x
└ loop(i) → x → rot_loop(x, i)


define is_prop_fam_S1(P: S1 ⇒ type, pP: (x: S1) ⇒ is_prop(P(x)), b0: P(S1.base)): b0 ≡[i → P(S1.loop(i))] b0 =
  i → pP(S1.loop(i), transp(j → P(S1.loop(i∧j)), ~i, b0), transp(j → P(S1.loop(i∨(~j))), i, b0), i)

define rot_is_equiv:
 (a: S1) ⇒ is_equiv(rot(a)) =
┌ base → id_is_equiv(S1)
└ loop(i) → is_prop_fam_S1(x → is_equiv(rot(x)), x → is_prop_is_equiv(rot(x)), id_is_equiv(_))(i)



// define inductively post_total_hopf: type = sum {
//   case base(: S1)
//   case loop(x: S1, base(x) ≡[] rot_loop(x, ))
// }


























