

define id(#A: type, a: A): A = a

define refl(#A: type, #a: A): a ≡ a = i → a

// TODO x.refl syntax
define x_refl(#A: type, a: A): a ≡ a = i → a

define fun_ext(#A: type, #B: A ⇒ type, #f #g: (x: A) ⇒ B(x), p: (x: A) ⇒ f(x) ≡ g(x)): f ≡ g =
  i → x → p(x, i)
/*
TODO new syntax

define fun_ext(
  #f #g: (x: #A) ⇒ #B(x),
  p: (x: A) ⇒ f(x) ≡ g(x)
): f ≡ g = i → x → p(x, i)
*/

/*
TODO new syntax
p.reverse
*/
define path_reverse(#A: type, #x #y: A, p: x ≡ y): y ≡ x =
  i → hcom(0, 1, x |i=0: p |i=1: x_refl(x))


define path_reverse_filler(#A: type, #x #y: A, p: x ≡ y): (─ → x) ≡[j → p(j) ≡ x] path_reverse(p) =
  j → i → hcom(0, j, x |i=0: p |i=1: x_refl(x))

define path_reverse_unit(#A: type, x: A): (─ → x) ≡[─ → x ≡ x] path_reverse(x_refl(x)) =
  path_reverse_filler(x_refl(x))

define dependent_path_reverse(A1 A2: type, A: A1 ≡ A2, x: A1, y: A2, p: x ≡[A] y): y ≡[^path_reverse(A)] x =
  i → com(0, 1, j → ^path_reverse_filler(A, j, i), x |i=0: p |i=1: x_refl(x))

/*
TODO can we statically determine use path_reverse or dependent_path_reverse?

like when type directed name resolution, we say one is a "sub choice" of another, like

define (p: #x ≡[#A] #y).reverse: y ≡[path_reverse(A)] x = ...
define (p: #x ≡ #y).reverse: y ≡ x = ...

we somehow mark the second one a "sub-case" of first one

so when we type directed name resolving on "reverse", if we checked that second one applies, we need to assert
the first one also applies, then we can use the second one, because it has a more efficient computational behaviour

*/


define trans(#A: type, #x #y #z: A, p1: x ≡ y, p2: y ≡ z): x ≡ z =
  i → hcom(0, 1, p1(i) |i=0: x_refl(x) |i=1: p2)


define fiber(A B: type, f: A ⇒ B, b: B): type = record {
  field from: A
  field is: f(from) ≡ b
}


// TODO what's a proper name for this?
define apd(#A: type, #P: A ⇒ type, f: (x: A) ⇒ P(x), x y: A, p: x ≡ y): coe(0, 1, i → P(p(i)), f(x)) ≡ f(y) =
  i → coe(i, 1, j → P(p(j)), f(p(i)))
