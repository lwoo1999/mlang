

define id(#A: type, a: A): A = a



define refl(#A: type, #a: A): a ≡ a = i → a

// x.refl
define x_refl(#A: type, a: A): a ≡ a = i → a

// a better name?
define coeij(#A: type, #x #y: A, p: x ≡ y, i j : I): p(i) ≡ p(j) =
  k → hcom(i, j, p(i) |k=0: x_refl(p(i))
                      |k=1: p)

define coeij_(#A: type, #x #y: A, p: x ≡ y, i j : I): p(i) ≡ p(j) =
  k → hcom(j, i, p(j) |k=0: p
                      |k=1: x_refl(p(j)))

define connection_both(#A: type, #x #y #z: A, p: x ≡ y, q: y ≡ z): p ≡[i → p(i) ≡ q(i)] q =
  i → j → hcom(0, 1, y |i=0: coeij(p, 1, j)
                       |i=1: coeij(q, 0, j)
                       |j=0: coeij(p, 1, i)
                       |j=1: coeij(q, 0, i))

define connection_or(#A: type, #x #y: A, p: x ≡ y): p ≡[i → p(i) ≡ y] x_refl(y) =
  connection_both(p, x_refl(y))

define connection_and(#A: type, #x #y: A, p: x ≡ y): x_refl(x) ≡[i → x ≡ p(i)] p =
  connection_both(x_refl(x), p)

// is this necessary when we already have coeij?
define path_reverse_filler(#A: type, #x #y: A, p: x ≡ y, i: I): p(i) ≡ x =
  coeij_(p, i, 0)

// p.reverse
define path_reverse(#A: type, #x #y: A, p: x ≡ y): y ≡ x = path_reverse_filler(p, 1)


define path_reverse_unit(#A: type, x: A): (─ → x) ≡[─ → x ≡ x] path_reverse(x_refl(x)) =
  path_reverse_filler(x_refl(x))


define path_reverse__filler(#A: type, #x #y: A, p: x ≡ y, i : I): y ≡ p(i) =
  coeij(p, 1, i)

define path_reverse_(#A: type, #x #y: A, p: x ≡ y): y ≡ x = path_reverse__filler(p, 0)


// p.reverse statically determined!!
define dependent_path_reverse(#A1 #A2: type, #A: A1 ≡ A2, #x: A1, #y: A2, p: x ≡[A] y): y ≡[^path_reverse(A)] x =
  i → com(0, 1, j → ^path_reverse_filler(A, j, i), x |i=0: p |i=1: x_refl(x))



// a * b

define path_compose_filler(#A: type, #x #y #z: A, xy: x ≡ y, yz: y ≡ z, j i: I) =
  hcom(0, j, xy(i) |i=0: x_refl(x) |i=1: yz)

define path_compose(#A: type, #x #y #z: A, xy: x ≡ y, yz: y ≡ z): x ≡ z =
  path_compose_filler(xy, yz, 1)

define path_compose_unit_r(#A: type, #x #y: A, p: x ≡ y): p ≡ path_compose(p, x_refl(y)) =
  path_compose_filler(p, x_refl(y))


define path_compose_unit_l(#A: type, #x #y: A, p: x ≡ y): p ≡ path_compose(x_refl(x), p) =
  i → j → hcom(0, 1, x |i=0: k → connection_and(p, j, k)
                       |j=0: x_refl(x)
                       |j=1: p)

// how can we statically choose which one to use?
/*
define dependent_path_compose(
  #A #B #C: type,
  #AB: A ≡ B, #BC: B ≡ C,
  #a: A, #b: B, #c: C,
  ab: a ≡[AB] b, bc: b ≡[BC] c): a ≡[^path_compose(AB, BC)] c = ???
*/


// TODO what syntax and name should this be? a.transp(p), p.transp(a), a^p, a|P, transp(a, p)???
define transport(#A #B: type, P: A ≡ B, a: A): B = coe(0, 1, P, a)

define transport_refl(#A: type, a: A): a ≡ transport(─ → A, a) =
  i → coe(0, i, ─ → A, a)


define subst(#A: type, B: A ⇒ type, #x #y: A, p: x ≡ y, bx: B(x)): B(y) =
  transport(i → B(p(i)), bx)



// #f #g: (x: #A) ⇒ #B(x),
define fun_ext(#A: type, #B: A ⇒ type, #f #g: (x: A) ⇒ B(x), p: (x: A) ⇒ f(x) ≡ g(x)): f ≡ g =
  i → x → p(x, i)

// TODO what's a proper name for this?
// define apd(#A: type, #B: A ⇒ type, f: (x: A) ⇒ B(x), x y: A, p: x ≡ y): coe(0, 1, i → B(p(i)), f(x)) ≡ f(y) =
//  i → coe(i, 1, j → B(p(j)), f(p(i)))


// cong(f, p) or p.map(f) or f.path_app(p) even f(p)?
define path_map(#A: type, #B: A ⇒ type, f: (x: A) ⇒ B(x), #x #y: A, p: x ≡ y): f(x) ≡[i → B(p(i))] f(y) =
  i → f(p(i))


// TODO define cong₂ in Cubical Agda




define is_contractible(A: type) = record {
  field center: A
  field to_center: (a: A) ⇒ a ≡ center
}

// f.fiber(b)??
define fiber_at(#A #B: type, f: A ⇒ B, b: B): type = record {
  field from: A
  field is: f(from) ≡ b
}

define is_equiv(A B: type) = record {
  field f: A ⇒ B
  field component: (b: B) ⇒ is_contractible(fiber_at(f, b))
}

define is_prop(A: type): type = (a b: A) ⇒ a ≡ b


define inductively h_level: type = sum {
  case contractible
  case suc(: h_level)
}

/* TODO local match expression or with expression
define is_h_level:
  h_level          ⇒ (type ⇒ type) =
┌ contractible     → is_contractible
└ suc(b) → match(b,
    ┌ contractible → is_prop
    └ suc(c)       → A → (x y: A) ⇒ is_h_level(b)(x ≡ y))
*/



define singleton(#A: type, center: A) = record {
  field a: A
  field to_center: a ≡ center
}

/* TODO incomplete
define singleton_is_contractible(#A: type, center: A):
   is_contractible(singleton(center)) =
   make(make(center, refl), a → j → ???)
*/

