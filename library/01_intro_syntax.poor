/**

"─"
  - used alone as introduces names as in argument list
  - used after as pattern, means introduce without name
"┬" empty pattern
"⊏" single pattern
"┌", "└", "├" is patterns with 2+ cases

"│" is just whitespace
**/

define id:
 (a: type, x: a) ⇒ a =
  ─        ─     → x

define bool = sum { case true false }

define inductively nat: type = sum {
  case zero
  case suc(nat)
}

define list: (a: type) ⇒ type = a → sum {
  case nil
  case cons(a, list(a))
}

define plus:
 (a       b: nat) ⇒ nat =
  ─     ┌ zero    → a
        └ suc(m)  → nat.suc(plus(a, m))


define plus2:
 (a       b: nat) ⇒ nat =
  ─     ┌ zero    → a
        └ suc(m)  → plus2(nat.suc(a), m)

define plus_pointwise:
 (a: nat) ⇒ plus(a) ≡(─ ↪ nat) plus2(a) =
┌ 
└

define plus_defined_twice:
 (a       b: nat) ⇒ nat =
  ─     ┌ zero    → a
        └ suc(m)  → nat.suc(plus_defined_twice(a, m))

define test001:
 (x y: nat, b: nat ⇒ type, c: (i: nat) ⇒ b(i)) ⇒ b(plus(x, y)) =
  ─ ─       ─              ─                   → c(plus_defined_twice(x, y))


define fun_ext:
 (a: type, b: a ⇒ type, f g: (x: a) ⇒ b(x), p: (x: a) ⇒ f(x) ≡(─ ↪ b(x)) g(x)) ⇒ f ≡(─ ↪ (x: a) ⇒ b(x)) g =
  ─        ─            ─ ─                 ─                                  → i ↪ x → p(x)[i]

define path_plus12: plus ≡(─ ↪ nat ⇒ nat) plus2 = fun_ext(nat, ─ → nat, plus, plus2,

define multi:
 (a       b: nat) ⇒ nat =
  ─     ┌ zero    → nat.zero
        └ suc(m)  → plus(a, multi(a, m))

define one = nat.suc(nat.zero)

define two = nat.suc(one)

define four = plus(two, two)

define eight = plus(four, four)

define sixteen = plus(eight, eight)

define sixteen2 = multi(four, four)



define test002:
 (x y: nat, b: nat ⇒ type, c: (i: nat) ⇒ b(i)) ⇒ b(plus2(nat.suc(x), y)) =
  ─ ─       ─              ─                   → c(plus2(nat.suc(x), y))


define ttt1:
  nat ⇒ nat =
  ─   → plus(two, four)

define ttt2:
  nat ⇒ nat =
  ─   → plus(four, two)


define ttt3:
  nat ⇒ nat =
  ─   → plus2(four, two)

define assert_tt2_eq_holder:
 (b: (nat ⇒ nat) ⇒ type, c: (i: nat ⇒ nat) ⇒ b(i)) ⇒ b(ttt1) =
  ─                      ─                         → c(ttt2)





define assert_nat_eq_holder2:
 (x y: nat, b: (nat ⇒ nat) ⇒ type, c: (i: nat ⇒ nat) ⇒ b(i)) ⇒ b(─ → plus(x, y)) =
  ─ ─       ─              ─                   → c(─ → plus(x, y))

define assert_tt2_eq_holder3:
 (b: (nat ⇒ nat) ⇒ type, c: (i: nat ⇒ nat) ⇒ b(i)) ⇒ b(ttt1) =
  ─                      ─                         → c(ttt3)

define ttt:
 (a b: nat, c: nat ⇒ type, d: type ⇒ type) ⇒ type =
  ─ ─       ─              ─               → d(c(plus(a, b)))


declare nat_is_even: nat ⇒ bool

define nat_is_odd:
  nat ⇒ bool =
┌ zero → bool.false
└ suc(m) → nat_is_even(m)

define nat_is_even =
┌ zero → bool.true
└ suc(m) → nat_is_odd(m)



define assert_nat_eq_holder:
 (b: nat ⇒ type, c: (i: nat) ⇒ b(i)) ⇒ b(sixteen) =
  ─              ─                   → c(sixteen2)


// TODO use def and fun syntax
define test0:
 (a b: type, f: a ⇒ b, func: (a ⇒ b) ⇒ type, g: func(f)) ⇒ func(f) =
  ─ ─        ─         ─                     ─           → g


define test1:
 (a b: type, f: a ⇒ b, func: (a ⇒ b) ⇒ type, g: func(f)) ⇒ func(id(a ⇒ b, f)) =
  ─ ─        ─         ─                     ─           → g


// ignored is a keyword to don't put the definition in the context at all, it just makes it type check

define ignored _ = { // "{" starts a let expression

  define fin3 = sum {
    case one two three
  }

  define fin3_pair = record {
    field a b: fin3
  }

  define inverse:
    fin3  ⇒ fin3 =
  ┌ one   → fin3.three
  ├ two   → fin3.two
  └ three → fin3.one

  define test:
   (intros a       b: fin3) ⇒ fin3 =
    ─    ┌ one   ┌ one      → fin3.three
         │       ├ two      → fin3.two
         │       └ three    → test(fin3.one, fin3.one, fin3.one) // recursive definitions
         ├ three   ─        → b
         └ ─       ─        → b // although first is a dash pattern, it doesn't introduce the name (yet)

  test
}
