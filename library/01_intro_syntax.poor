/**

"─"
  - used alone as introduces names as in argument list
  - used after as pattern, means introduce without name
"┬" empty pattern
"⊏" single pattern
"┌", "└", "├" is patterns with 2+ cases

"│" is just whitespace
**/


define inductively nat: type = sum {
  case zero
  case suc(: nat)
}

define inductively nat2: type = sum {
  case zero
  case suc(: nat)
}


define refl(#A: type, #x: A): x ≡ x = i → x

// this fails because we have nominal equality for recursive types!
// define fails: nat ≡ nat2 = refl

define flat: type = sum {
   case true false
}

define flat2: type = sum {
   case true false
}

// non-recursive record and sum has structural equality, their case/field name/order needs to be exactly the same
define flat_is_ok: flat ≡ flat2 = refl

define suc(a: nat): nat = nat.suc(a)

define plus:
 (a       b: nat) ⇒ nat =
  ─     ┌ zero    → a
        └ suc(m)  → suc(plus(a, m))


define multi:
 (a       b: nat) ⇒ nat =
  ─     ┌ zero    → nat.zero
        └ suc(m)  → plus(a, multi(a, m))

define one = nat.suc(nat.zero)

define fib:
(: nat) ⇒ nat =
┌ zero → nat.zero
├ suc(zero) → one
└ suc(suc(b)) → plus(fib(nat.suc(b)), fib(b))



define two = nat.suc(one)

define four = plus(two, two)

define eight = plus(four, four)

define nine = nat.suc(eight)

define ten = plus(eight, two)

define thirty_four = plus(ten, plus(ten, plus(ten, four)))

define fib_ten_eq: thirty_four ≡ fib(nine) = refl

define sixteen = plus(eight, eight)

define sixteen2 = multi(four, four)

define record_of_refl = record {
  field #A: type
  field #x #y: A
  field eq: x ≡ y
}




define test_record_of_refl: eight ≡ eight = record_of_refl.make(refl(#_, #eight)).eq

define record_of_refl2(#A: type): type = record {
  field #x #y: A
  field eq: x ≡ y
}


define test_record_of_refl2: eight ≡ eight = record_of_refl2.make(refl(#_, #eight)).eq


define test_record_of_metas = record {
  field test: (#a: nat, b: a ≡ a) ⇒ type
  field a c: test(refl(#_, #four))
  field b: test(refl(#_, #eight))
}

/*

the meta is solved with

debug: meta solved with Reference(0,0) // or in code ⇒ nat
debug: meta solved with Reference(0,8) // or in code ⇒ sixteen1

these are LOCAL variables, and they are VERY SHORT!!

what more we can do? we can pick the shortest one from the chain of evaluation steps

*/
define sixteen_eq: sixteen ≡ sixteen2 = refl



define fun_ext(#A: type, #B: A ⇒ type, #f #g: (x: A) ⇒ B(x), p: (x: A) ⇒ f(x) ≡ g(x)): f ≡ g =
  i → x → p(x, i)

define fun_ext2(A: type, B: A ⇒ type, f g: (x: A) ⇒ B(x), p: (x: A) ⇒ f(x) ≡ g(x)): f ≡ g =
  fun_ext(#_, #_, #_, #_, p)

define fun_ext3(A: type, B: A ⇒ type, f g: (x: A) ⇒ B(x), p: (x: A) ⇒ f(x) ≡ g(x)): f ≡ g =
  fun_ext(p)

define id(a: type, x: a): a = x


define test1(a b: type, f: a ⇒ b, func: (a ⇒ b) ⇒ type, g: func(f)): func(id(_, f)) = g

define apd(A: type, P: A ⇒ type, f: (x: A) ⇒ P(x), x y: A, p: x ≡ y): coe(0, 1, i → P(p(i)), f(x)) ≡ f(y) =
  i → coe(i, 1, j → P(p(j)), f(p(i)))

define symm(A: type, x y: A, p: x ≡ y): y ≡ x =
  i → hcom(0, 1, x, k | i=0 → p(k) | i=1 → x)

define symm_filler(A: type, x y: A, p: x ≡ y): (─ → x) ≡[j → p(j) ≡ x] symm(A, x, y, p) =
  j → i → hcom(0, j, x, k | i=0 → p(k) | i=1 → x)

define symm_unit(A: type, x: A): (─ → x) ≡[─ → x ≡ x] symm(A, x, x, (─ → x)) =
  symm_filler(A, x, x, ─ → x)

define symmp(A1 A2: type, A: A1 ≡ A2, x: A1, y: A2, p: x ≡[i → A(i)] y): y ≡[i → symm(type, A1, A2, A, i)] x =
  i → com(0, 1, j → symm_filler(type, A1, A2, A, j, i), x, k | i=0 → p(k) | i=1 → x)

define trans(A: type, x y z: A, p1: x ≡ y, p2: y ≡ z): x ≡ z =
  i → hcom(0, 1, p1(i), k | i=0 → x | i=1 → p2(k))



define fiber(A B: type, f: A ⇒ B, b: B): type = record {
  field from: A
  field is: f(from) ≡ b
}

define bool = sum { case true false }

declare nat_is_even: nat ⇒ bool

define nat_is_odd:
  nat ⇒ bool =
┌ zero → bool.false
└ suc(m) → nat_is_even(m)

define nat_is_even =
┌ zero → bool.true
└ suc(m) → nat_is_odd(m)


/*

app (l: list(/A/)) of (a: nat): A =


define implicitly (a: list(/A/): nat ⇒ A =

projection (p: /x/ ≡ /y/).reverse: y ≡ x =

*/

define record_test = record {
  field a: type
  field b: a
  field c: a ⇒ type
  field d: c(b)
}



define ttt1(a: nat): nat = plus(two, four)

define ttt2(a: nat): nat = plus(four, two)

define assert_tt2_eq_holder(b: (nat ⇒ nat) ⇒ type, c: (i: nat ⇒ nat) ⇒ b(i)): b(ttt1) = c(ttt2)

define assert_nat_eq_holder2(x y: nat, b: (nat ⇒ nat) ⇒ type, c: (i: nat ⇒ nat) ⇒ b(i)): b(─ → plus(x, y)) =
  c(─ → plus(x, y))



define err: type = record {
  field a: err
}

/* this loops, just like Agda, eta for recursive record, maybe we should mark non-guarded records and just say they are empty
define test_err(a b: err): a ≡ b = ─ → a
*/





define plus2:
 (a       b: nat) ⇒ nat =
  ─     ┌ zero    → a
        └ suc(m)  → plus2(suc(a), m)



define plus_pointwise_lemma:
 (a   m: nat) ⇒ plus2(suc(a), m) ≡ suc(plus2(a, m)) =
  ─ ┌ zero    → ─ → suc(a)
    └ suc(n)  → i → plus_pointwise_lemma(suc(a), n, i)

/*

define plus_pointwise:
 (a       b: nat) ⇒ plus(a, b) ≡ plus2(a, b) =
  ─     ┌ zero    → ─ → b
        └ suc(m)  → plus_pointwise() // suc(plus(a, m)) ≡ plus2(suc(a), m)

define path_plus12: plus ≡ plus2 = fun_ext(nat, ─ → nat, plus, plus2,

*/

define plus_defined_twice:
 (a       b: nat) ⇒ nat =
  ─     ┌ zero    → a
        └ suc(m)  → nat.suc(plus_defined_twice(a, m))

define test001(x y: nat, b: nat ⇒ type, c: (i: nat) ⇒ b(i)): b(plus(x, y)) = c(plus_defined_twice(x, y))






define test002(x y: nat, b: nat ⇒ type, c: (i: nat) ⇒ b(i)): b(plus2(nat.suc(x), y)) = c(plus2(nat.suc(x), y))


define ttt3(a: nat): nat = plus2(four, two)






define assert_tt2_eq_holder3(b: (nat ⇒ nat) ⇒ type, c: (i: nat ⇒ nat) ⇒ b(i)): b(ttt1) = c(ttt3)

define ttt(a b: nat, c: nat ⇒ type, d: type ⇒ type): type = d(c(plus(a, b)))




define assert_nat_eq_holder(b: nat ⇒ type, c: (i: nat) ⇒ b(i)): b(sixteen) = c(sixteen2)


define test0(a b: type, f: a ⇒ b, func: (a ⇒ b) ⇒ type, g: func(f)): func(f) = g



define fin3_copy = sum {
  case one two three
}

define ig = run { // "{" starts a let expression

  define fin3 = sum {
    case one two three
  }

  /* don't work because inductive definitions must be at top level
  define inductively fin3 = sum {
    case one two three
  }
  */

  define fin3_pair = record {
    field a b: fin3
  }


  define inverse:
    fin3  ⇒ fin3 =
  ┌ one   → fin3.three
  ├ two   → fin3.two
  └ three → fin3.one

  define test:
   (intros a       b: fin3) ⇒ fin3 =
    ─    ┌ one   ┌ one      → fin3.three
         │       ├ two      → fin3.two
         │       └ three    → test(fin3.one, fin3.one, fin3.one) // recursive definitions
         ├ three   ─        → b
         └ ─       ─        → b // although first is a dash pattern, it doesn't introduce the name (yet)

  test
}

define ignored_again = ig(fin3_copy.one, fin3_copy.one, fin3_copy.three)

