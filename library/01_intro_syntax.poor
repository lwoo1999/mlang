/**

"─"
  - used alone as introduces names as in argument list
  - used after as pattern, means introduce without name
"┬" empty pattern
"⊏" single pattern
"┌", "└", "├" is patterns with 2+ cases

"│" is just whitespace
**/

define apd(A: type, P: A ⇒ type, f: (x: A) ⇒ P(x), x y: A, p: x ≡ y): coe(0, 1, i → P(p(i)), f(x)) ≡ f(y) =
  i → coe(i, 1, j → P(p(j)), f(p(i)))

define symm(A: type, x y: A, p: x ≡ y): y ≡ x =
  i → hcom(0, 1, x, k | i=0 → p(k) | i=1 → x)

define symm1(A: type(1), x y: A, p: x ≡ y): y ≡ x =
  i → hcom(0, 1, x, k | i=0 → p(k) | i=1 → x)

define symm_unit(A: type, a: A): (i → a) ≡(─ → a ≡ a) symm(A, a, a, (i → a)) =
  j → i → hcom(0, j, a, k | i=0 → a | i=1 → a)

// symm_p(p: /x/ ≡(/A[_]/) /y/): y ≡(A.inverse) x
// define symm_p(A1 A2: type, A: A1 ≡ A2, x: A1, y: A2, p: x ≡(i → A(i)) y): y ≡(i → symm1(type, A1, A2, A, i)) x =
//  i → com(0, 1, x, j →


define trans(A: type, x y z: A, p1: x ≡ y, p2: y ≡ z): x ≡ z =
  i → hcom(0, 1, p1(i), k | i=0 → x | i=1 → p2(k))

define inductively nat: type = sum {
  case zero
  case suc(:nat)
}

define bool = sum { case true false }

declare nat_is_even: nat ⇒ bool

define nat_is_odd:
  nat ⇒ bool =
┌ zero → bool.false
└ suc(m) → nat_is_even(m)

define nat_is_even =
┌ zero → bool.true
└ suc(m) → nat_is_odd(m)

define fun_ext(a: type, b: a ⇒ type, f g: (x: a) ⇒ b(x), p: (x: a) ⇒ f(x) ≡ g(x)): f ≡ g =
  i → x → p(x, i)


/*

define fun_ext(f g: (x: /a/) ⇒ /b(x)/, p: (x: a) ⇒ f(x) ≡ g(x)): f ≡ g =
  i → x → p(x, i)

projection (p: /x/ ≡ /y/).reverse: y ≡ x =

*/

define record_test = record {
  field a: type
  field b: a
  field c: a ⇒ type
  field d: c(b)
}



define suc(a: nat): nat = nat.suc(a)

define plus:
 (a       b: nat) ⇒ nat =
  ─     ┌ zero    → a
        └ suc(m)  → suc(plus(a, m))


define multi:
 (a       b: nat) ⇒ nat =
  ─     ┌ zero    → nat.zero
        └ suc(m)  → plus(a, multi(a, m))

define one = nat.suc(nat.zero)

define two = nat.suc(one)

define four = plus(two, two)

define eight = plus(four, four)

define sixteen = plus(eight, eight)

define sixteen2 = multi(four, four)

define ttt1(a: nat): nat = plus(two, four)

define ttt2(a: nat): nat = plus(four, two)

define assert_tt2_eq_holder(b: (nat ⇒ nat) ⇒ type, c: (i: nat ⇒ nat) ⇒ b(i)): b(ttt1) = c(ttt2)

define assert_nat_eq_holder2(x y: nat, b: (nat ⇒ nat) ⇒ type, c: (i: nat ⇒ nat) ⇒ b(i)): b(─ → plus(x, y)) =
  c(─ → plus(x, y))

define id(a: type, x: a): a = x


define err: type = record {
  field a: err
}

/* this loops, just like Agda, eta for recursive record, maybe we should mark non-guarded records and just say they are empty
define test_err(a b: err): a ≡ b = ─ → a
*/





define plus2:
 (a       b: nat) ⇒ nat =
  ─     ┌ zero    → a
        └ suc(m)  → plus2(suc(a), m)



define plus_pointwise_lemma:
 (a   m: nat) ⇒ plus2(suc(a), m) ≡ suc(plus2(a, m)) =
  ─ ┌ zero    → ─ → suc(a)
    └ suc(n)  → i → plus_pointwise_lemma(suc(a), n, i)

/*

define plus_pointwise:
 (a       b: nat) ⇒ plus(a, b) ≡ plus2(a, b) =
  ─     ┌ zero    → ─ → b
        └ suc(m)  → plus_pointwise() // suc(plus(a, m)) ≡ plus2(suc(a), m)

define path_plus12: plus ≡ plus2 = fun_ext(nat, ─ → nat, plus, plus2,

*/

define plus_defined_twice:
 (a       b: nat) ⇒ nat =
  ─     ┌ zero    → a
        └ suc(m)  → nat.suc(plus_defined_twice(a, m))

define test001(x y: nat, b: nat ⇒ type, c: (i: nat) ⇒ b(i)): b(plus(x, y)) = c(plus_defined_twice(x, y))






define test002(x y: nat, b: nat ⇒ type, c: (i: nat) ⇒ b(i)): b(plus2(nat.suc(x), y)) = c(plus2(nat.suc(x), y))


define ttt3(a: nat): nat = plus2(four, two)






define assert_tt2_eq_holder3(b: (nat ⇒ nat) ⇒ type, c: (i: nat ⇒ nat) ⇒ b(i)): b(ttt1) = c(ttt3)

define ttt(a b: nat, c: nat ⇒ type, d: type ⇒ type): type = d(c(plus(a, b)))






define assert_nat_eq_holder(b: nat ⇒ type, c: (i: nat) ⇒ b(i)): b(sixteen) = c(sixteen2)


define test0(a b: type, f: a ⇒ b, func: (a ⇒ b) ⇒ type, g: func(f)): func(f) = g


define test1(a b: type, f: a ⇒ b, func: (a ⇒ b) ⇒ type, g: func(f)): func(id(a ⇒ b, f)) = g

define fin3_copy = sum {
  case one two three
}

define ig = { // "{" starts a let expression

  define fin3 = sum {
    case one two three
  }

  define fin3_pair = record {
    field a b: fin3
  }


  define inverse:
    fin3  ⇒ fin3 =
  ┌ one   → fin3.three
  ├ two   → fin3.two
  └ three → fin3.one

  define test:
   (intros a       b: fin3) ⇒ fin3 =
    ─    ┌ one   ┌ one      → fin3.three
         │       ├ two      → fin3.two
         │       └ three    → test(fin3.one, fin3.one, fin3.one) // recursive definitions
         ├ three   ─        → b
         └ ─       ─        → b // although first is a dash pattern, it doesn't introduce the name (yet)

  test
}

define ignored_again = ig(fin3_copy.one, fin3_copy.one, fin3_copy.three)

define list(a: type): type = sum {
  case nil
  case cons(:a, :list(a))
}

